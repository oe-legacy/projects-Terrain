% -*- mode: latex; mode: auto-fill; coding: utf-8; -*-

\chapter{Procedural generation of content}
\label{chap:noise}
What is known as procedural or synthetic generation of content are
used extensively in computer graphics to enable generation of natural
looking details. By generating details, in contract to doing them by
hand, boring work typically done by computer artists can be cut down,
and instead be used on designing the overall look and feel.
%
The term procedural generation of content is very fuzzy and covers
quite a large area of different techniques, but boils down to some
kind of algorithm that produces data \citebook{page~12}{ebert2003}.
Typically where a number of parameters can be specified to control the
generation process in a way that alters the result in a intuitive way
based on the parameters.

\section{Generating irregular data}
We have chosen to concentration our effort on irregular data generation
minded on textures, therefore only this type type of data generation
will be covered in the following.
%
The basic building blocks when generating irregular data are
noise functions. A noise function is a function that is apparently
stochastic and will break up monotony of the patterns that would
otherwise be too regular \citebook{page~67-78}{ebert2003}.
%
Typically a noise function is a function of the space so the arguments
can be filled directly when rendering, e.g. $f(x,y,z)$.
%
An obvious stochastic primitive is uniformly distributed random
numbers with no correlation, which is also known as white noise.
In computer graphics however true random numbers are rarely used,
because they are not controllable.
Instead pseudo random number (PRN) generators are used to produce a
fair approximation to white noise. These however are controllable and
furthermore produce the same number sequences on two successive runs
provided the algorithm is started with the same preconditions.
%
Another property of white noise that we do not want is that it is
uncorrelated in all function values. This causes problems in computer
graphics because of rounding errors in the floating point
representation used when rendering. Instead we use a low-pass filtered
version of an approximation to white noise.

There are many different ways of using PRN to produce noise functions,
each method generate functions with different properties. General the
functions are divide into categories based on how they generate the
noise. To making an important and often misunderstood point regarding
what precisely defines the famous Perlin noise function, we will
introduce two basic categories of noise functions: Value and gradient
noise, which both also are categorized as lattice noise.

\subsection{Lattice noise}
In geometry a lattice is a discrete subgroup (a set of points) in the
same dimension as the basis vectors spanning the vector space. A
lattice can be viewed as a regular tiling of space by primitive cells
forming a grid structure. The most used lattice in computer graphics is the
regular Cartesian grid, which can be viewed as a tiling of
squares in two dimensions, see figure \ref{fig:square-lattice}. For
clarity figure \ref{fig:lattices} also provides other examples of
lattices.

\begin{figure}[!h]
  \centering
  \subfloat[Triangle lattice.]{
    \includegraphics[width=3cm]{200px-Equilateral_Triangle_Lattice}
    \label{fig:lattice1}
  }
  \hspace{4mm}
  \subfloat[Rhombic lattice.]{
    \includegraphics[width=3cm]{200px-Rhombic_Lattice}
    \label{fig:lattice2}
  }
  \hspace{4mm}
  \subfloat[Square lattice.]{
    \includegraphics[width=3cm]{200px-SquareLattice}
    \label{fig:square-lattice}
  }
  \hspace{4mm}
  \subfloat[Parallelogram lattice.]{
    \includegraphics[width=3cm]{200px-Oblique_Lattice}
    \label{fig:lattice4}
  }
  \caption{Four simple lattice types in two dimensions.}
  \label{fig:lattices}
\end{figure}

Lattice noise is generated by having a lattice, and then for each
lattice point generating one or more random values for that point
depending on the type of noise we want.
%
The low-pass filtering is then done by interpolating the values at the
grid points to fill the entire space between the lattice
points. Different interpolation scheme can be used to calculate these
values, which yield different properties for the noise function.

\subsubsection{Value noise}
Value noise is the simplest type of lattice noise, here the values
stored at each grid point are the values that are interpolated and
returned when the function is evaluated.

\subsubsection{Gradient noise}
Gradient noise however have generates a gradient at each point in the
lattice, which is a vector with the same dimension as the number of
dimensions wherein the function is defined. The gradients in each grid
point is then used to calculate a continuous function between the grid
points, which again can be used to evaluate a noise value.
%
The gradient noise category includes the now famous noise
function known as Perlin noise, first described by Ken Perlin in
his famous paper: \citeabook{Perlin85}.

\section{Composite of layers}
Noise alone does not make realistic looking textures, only by carefully
choosing the noise parameters and cleverly combining many layers of
different looking noise results in naturally beauty. In the following,
we will focus on generating a volumetric texture of clouds, but the
description illustrates the overall process of how to generate and
combine noise functions.

To enable writing of how to combine noise functions, we will borrow
terminology from the field of digital signal processing (DSP).
In DSP the term \emph{sample frequency}
describes the space between to consecutive samples, and the term
\emph{amplitude} the maximum value of the function.

\hrule

To generate clouds we want to create some large ... to represent the
basic outline of the clouds shapes, this is done with a low frequency noise
with a large amplitude illustrated in figure \ref{} for one dimension.

Then we want to add some layers of detail to these basic shapes, this
is done by combining the basic shapes with noise functions that have
higher frequencies but lower amplitude. The details comes form the
higher frequencies, but because we also want the basic shapes to be
the most dominant the amplitude of these details are lowered. We
change the frequency and amplitude in octaves because this is ...
For each level of detail that is added the frequency is doubled while
the amplitude is halved. We have used value noise to generate four
layers of white noise as show in figure \ref{}.

***illustrated by the following MatLab program

in different resolutions and combined them one by one by first
re-sampling, them combining and lastly blurring the result to even out
re-sampling artifacts.


\section{Implementation}
When implementing noise functions, one must chose where the
computations are placed. One option is to do all computations as
precomputations and then use the resulting noise texture for look up
at run-time. Another option is to do all the computations at
run-time. The main advantage of doing the calculation as precomputation
is an increase in run-time performance, where as doing the calculations
at run-time enable adaption in LOD in relation to the camera
position. For the run-time computations to be fast enough to be done
in real-time that they are usually done on the GPU, but although noise
functions exists in the GLSL API, they are not recommended because
their behavior are not specific by the specification and are
implemented differently in hardware by different vendors and different
hardware generations. So developers that want to do the calculations
at run-time, instead use a hybrid solution, generating a small noise
texture which can be used to implement more sophisticated noise
function on the GPU.
%
We however have chosen to do all the calculations as precomputations
implemented on the CPU, our implementation is based the
\code{RandomGenerator} class of OpenEngine which is based on the PRN from
\citebook{page~278-283}{NRIC2}.
%
The entire algorithm of generating noise, composing layers, and
blurring them can be written as the following recursive function:

*** insert recursive generation code.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% End:
